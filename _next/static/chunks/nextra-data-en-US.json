{"/awesome-teaching":{"title":"Awesome Teaching","data":{"":"The Rules, from Teaching Tech Together:\nBe kind: all else is details.\nRemember that you are not your learners…\n…that most people would rather fail than change…\n…and that ninety percent of magic consists of knowing one extra thing.\nNever teach alone.\nNever hesitate to sacrifice truth for clarity.\nMake every mistake a lesson.\nRemember that no lesson survives first contact with learners…\n…that every lesson is too short for the teacher and too long for the learner…\n…and that nobody will be more excited about the lesson than you are.\n\n\nTeach Computing . Org\nPedagogy Quick Reads\n\n\nFrom Hello World @raspberrypi\nThe Big Book of Computing Pedagogy\nThe Big Book of Computing Content\n\n\nMicromaterials!"}},"/curriculum-design":{"title":"Curriculum Design","data":{"":"This is a collection of curriculum design principles that I've invented (or discovered?) since I started teaching programming. Some of them I've used for many years and have been the foundation of my teaching, others are new and I hope to use soon.Inspired by the Pedagogy Quick Reads, I've tried to introduce each of these design principles as something simple and actionable. To learn more about the ideas behind these design princples, you can find them in my notes. The notes are less clear than these pages but will have more detail, links to relevant literature, open questions, and all sorts of linked ideas."}},"/curriculum-design/big-picture-diagrams":{"title":"Big Picture Diagrams","data":{"":"Big-Picture Diagrams are a simple enough idea but very useful for setting learner expectations, motivating course objectives, structuring discussions, and curriculum planning. Before looking at some ways to use Big-Picture Diagrams let's see what they aren't. They aren't concept maps, learning objective graphs, ontologies, or any other formal representation of course objectives.Big-Picture Diagrams are informal diagrams representing what a learner is expected to do with what they learn. Diagrams can show the communication dynamics of a team project, the roles of different technical components in a system, or highlight the ethical and social considerations in a project.Each curriculum calls for it's own diagram tailored to the level of your learners, the course objectives, and any other relevant details. It's even useful to have different diagrams at different points in the curriculum. For example one high-level diagram introduced on day 1 to illustrates the end goal of your course, and smaller diagrams that zoom in on different portions of the main diagram over time.I even find it helpful to make these diagrams as a first step in curriculum design before scoping technical content, beginning any lesson plans, assessments, projects, or resources. Starting with a clear and conversational idea of what learners should do helps me decide what to exclude from the curriculum and makes the rest of curriculum design more intuitive.Starting with a clear big-picture has also helped me find un-intuitive design decisions. Starting with a diagram helped me see that the fundamental learning objective for web development is actually collaborative writing - project planning, software development, UI/UX design ... everything else relies on learners' abilities to collaboratively write a document. This led to starting programming courses with a full module on version control, project managment workflows and markdown before learning any code. (See the Spiderweb Curriculum for more on this idea.)Enough words, here are some diagrams for inspiration.","programming-is-writing#Programming is Writing":"These high-level diagrams show how collaborative writing and collaborative programming are similar.You can use them alongside an exercise where learners try to edit one google doc at the same time to movitave version control, or you could use them clarify the relationship between source code and running programs in the context of a group project.","collaborative-development#Collaborative Development":"This progression of diagrams build a big picture of web development starts with collaborative writing in a project context and gradually introduces aspects of Web Development, ending with basic web pages that interact with users and process their data.","data-science#Data Science":"The first diagram first introduces a big-picture understanding of data science. The second diagram zooms in on one leg of the triangle (analyzing data) and illustrates how members of a data science team might collaborate around a code base to learn from data."}},"/curriculum-design/connections-are-concepts":{"title":"Connections Are Concepts","data":{"":"Programming is complicated, there are many concepts to learn and all of the concepts are related. A simple way to approach this is to say that your learners have two types of knowledge to build:\nConcepts: The individual concepts of programming, things like variables and APIs and repositories. Studying each of these concepts separately is important but not enough.\nConnections: How individual concepts relate to each other. For example once you understand variables and arrays separately, you will still need to study reference vs. value (how variables store arrays in memory).\n\nHowever this Concept/Connection distinction can be blurry; is reference vs. value a Concept or a Connection?I've find it helpful to think of each Connection as just another Concept. The biggest advantage to this approach has been to ....... asdfWhen defining learning objectives, this framing can help to avoid overlooking or hand-waving away tricky and important objectives like reference vs. value.\nThen you'll make room in your learning objectives and schedule to teach this properly\nMaking space in your curriculum for these tricky connecting concepts may also help with [[Learner Trust]] by implicitly acknowledging that something will be challenging, and the learner isn't expected to \"just figure it out\" or \"get it later\". #question"}},"/curriculum-design/defining-task-classes":{"title":"Defining Task Classes","data":{"":""}},"/curriculum-design/planning-documents":{"title":"Planning Documents","data":{"":""}},"/curriculum-design/prismm":{"title":"Prismm","data":{"":"PRISMM is an approach for structuring lessons inspired by PRIMM. PRISMM includes an extra situating step after students have studied a program, but before they write their own similar programs. This step is for exploring how software relates to the wider world. You can visualize the PRISMM process like this:\n\n\ndiagram adapted from primmportal.org\nTo start using PRISMM in your class you can begin by sharing out any piece of level-appropriate code as a study reference, with some support learners can get used to guide their own study with the PRISMM steps. Doing this regularly with a series of programs that progress alongside your learners is a (relatively) low-effort way to practice teaching with PRISMM. If you would like more guidance to get started, try using existing resources for PRIMM and adding a little extra time for a situating discussion. PRIMM Portal has a collection of lesson plans for Python.The PRISMM steps in more detail:","predict#Predict":"Students discuss a program and predict what it might do, drawing or writing out what they think will be the output. At this level, the focus is on the function of the code.","run#Run":"Students run the program so that they can test their prediction and discuss in class.","investigate#Investigate":"The teacher provides a range of activities to explore the structure of the code; this involves activities such as tracing, explaining, annotating, and debugging. Study Lenses is has many features to support investigating code.","situate#Situate":"Discuss who wrote the program, why they wrote it, who would use the program, and why they would use it. Seeing the intentions behind and effects of software can help learners understand their digital world, and gain a sense of agency.","modify#Modify":"Students edit the program to change its functionality or purpose via a sequence of increasingly challenging exercises; the transfer of ownership moves from the code being ‘not mine’ to ‘partly mine’ as students gain confidence by extending the function of the code","make#Make":"Students design a new program that uses the same structures as the code they studied, but is designed to solve a differnet problem or is adapted for a different end user."}},"/curriculum-design/spiderweb-curriculum":{"title":"Spiderweb Curriculum","data":{"":"... introduction ... connect to big picture diagrams ..","spiderweb-diagrams#Spiderweb Diagrams":"Imagine a spider web with two types of thread:\nSkills: The lines going out from the center represent the skills your learners will practice each and every week.\nTechnologies: The circles going out from the center represent the languages and technologies your learners will cover in each module.\n\nA Spiderweb Curriculum starts in the center of the web practicing as many skills as possible, using the fewest technologies possible. This can mean explicitly learning version control and project management workflows while simply collaborating on markdown files. After practicing full group projects written in markdown, you might expand to the second circle by introducing HTML and CSS while still practicing all of the skills leanred in the inner circle, ..."}},"/curriculum-design/spiral-curriculum":{"title":"Spiral Curriculum","data":{"":""}},"/design-principles":{"title":"Design Principles","data":{"":"Above all De Nepo is about designing open educational resources that work for all sorts of learners, educators and educational contexts. We know that no design will work perfectly for everyone, so before explaining our solutions we want to share our design principles.We hope these design princples can make your education more accessible, whether by helping you use use our resources directly or by guiding your own designs.","curriculum-design#Curriculum Design":"Learner Trust: The foundation of any successful curriculum is the learners' trust. If you as an educator can maintain your learners' trust, you will be able to work through problems in the curriculum's design. If you lose your learners' trust, it does not matter how amazing your content is.\nTime is Importance: One of the hardest and most important decisions in curriculum design is what not to teach. Removing some objectives to make more time for others can help build Learner Trust by sending the message that this topic important, is not easy to learn, and there will be support.\nExplicitly Teach the Implicit: Make the time in your curriculum and in your class to explicitly teach skills that experienced developers take for granted, or don't even notice. Such as knowing how to read a file of code, or how to do a good internet search. Even if a learner could figure this out by trial and error, this will take a lot of time, is not guaranteed, and can harm Learner Trust.\nName Things: Name tiny concepts that experienced programmers take for granted. Naming small concepts will help learners isolate, practice and discuss these concepts. Naming a comcept also emphasizes that it is important, and that it's something learners are not expected to know yet. Naming things is one strategy for Explicitly teaching the Implicit.","content--tooling-design#Content & Tooling Design":"Study Code, Not Explanations: 1) Teach learners how to study code. 2) Provide the resources to study code effectively. 3) Write level-appropriate code intended for study. 4) Allow learners construct their own understanding.\nLearner-Accessible Tooling: Design your content authoring and managment processes so learners can realistically adapt the content to their needs. Having all aspects of a course be learner-accessible is not always realistic, but making as much of the content learner-accessible as possible will go a long way.\nContext is Content: Where and how a learner studies something is a learning objective, whether you inteded it to be or not. Design your learners' study and class workflows to mirror professional workflows so the time they spend navigating your course doubles as a learning objective.\nPeel Away Principle: Design configurable layers of pedagogical support on top of existing development environemnts. These layers can be gradually peeled away to reveal a full development environment. This approach to scaffolding can help ease skill transfer costs, and avoid the expertise reversal effect."}},"/":{"title":"Index","data":{"":"","open-education#Open Education":"Taking cues from the DevOps movement, we aim to treat content as cattle, and also to spread local learnings globally. Small modular modules are preferred, as they're more composable and like the bazaars of the Unix philosophy.In recognition of the reusability paradox, we also intend to create the infrastructure to create fast prototypes and adapt existing ones. For example an API to provide, on demand, functions of specific difficulty levels, features, etc.We also want to drive adoption of more exploratory investigation into ways to inform the content created for Computing Education; for example, corpus analysis of docs to inform materials for \"how to read docs\".","open-research#Open Research":"We want to encourage open research and replication in Computing Education by making prototypes used in studies immediately available to all researchers under an open license. Researchers can share their research questions, experimental designs and interventions before running experiments and their data afterwards, all in a single repository.Replications following the same or different methodologies can be tracked via forks, making related research more cumulative and navigable."}},"/lesson-materials":{"title":"Lesson Materials","data":{"":""}},"/web-development-curriculum":{"title":"Web Development Curriculum","data":{"":"","what-is-programming#What is Programming?":"Programming is communication. It's also a lot of other things, but this\ncurriculum will focus on the different ways you communicate with your code.When you write code you are really just writing a text document, exactly like\nyou might write an email or a note. The biggest difference between an email and\na computer program is who you are writing for.When you write an email you're writing for the person who will be reading it.\nWhen you write a computer program you are writing for 3 very different audiences\nat the same time! One single document (your code) needs to be understandable to:\nDevelopers: A developer needs to read your code and understand what you\nwere trying to do and why.\nComputers: Your code needs to have perfect syntax so the computer can\nparse it, and you must write instructions that are allowed by the programming\nlanguage or the computer will throw an error.\nUsers: The instructions you give to the computer must create an intuitive\nand pleasant experience for the user.\n\nBeing a developer means understanding how all these characters interact, then\ncommunicating with everyone involved to deliver quality software within your\nproject's constraints. This diagram shows the different channels of\ncommunication in a software project:","layers-of-skills#Layers of Skills":"Learn more about the curriculum modules in the Class Repo Template\nSoftware Development is a many layered skill. One way to break it down is to think of these layers:\nPlanning and Collaborating: Breaking down large problems into tasks that can be shared\n\nThis is introduced in the Workflows and Agile Develompent modules, and practiced in every other module\n\n\n\nSource Code: The basic literacy of programming\nLearning the key words (vocabulary) and syntax (grammar) for your programming language\nBeing able to read your code out loud, tracing it's execution as a computer would\nUnderstanding what the developer wanted to say with their code\n\nWelcome to JS will focus on these skills_\n\n\n\nMachine Instructions: The basic mechanics of programming\nUnderstanding the life-cycle of your program\nUnderstand how the computer will interpret your source code to create a running program\nUnderstand what about your code matters to the computer, and what matters to people\nFixing syntax errors that occur when you try to run your code\nPredicting which lines of code will be executed in which order\nPredicting how each line of code will change what is stored in program memory\nReading error messages & callstacks to fix fix semantic errors that occur when you run your code\n\nInside JS and Asynchronous Programming will focus on these skills_\n\n\n\nProblem Solving & Algorithms: Breaking down large problems to be solved in small steps\nUnderstanding a coding challenge and being able to break it down in different ways\nDetermining which solution strategies are correct for which types of problems\nUnderstanding how test cases are used to describe your solution strategy\nIdentifying the best language feature to use with your strategy\nReading test cases to understand how code is supposed to behave\nUsing Test Cases to structure your solution design process (Test Driven Development)\nIdentifying and isolating mistakes in your code by reading failing test cases\nDemonstrating your code does what you think it does by passing test cases\n\nBehavior, Strategy, Implementation Module will focus on these skills\n\n\n\nSoftware Design: Organizing smaller pieces of code into full software solutions\n\nEvery module starting with Separation of Concerns will focus on these skills\n\n\n\nContext: Who uses a program, what is it's impact, and where did it come from?\nReal people will use your software, is it accessible to them?\nYour software exists in a society, what it's impact on others?\nSomeone planned and build your software, what were their motivations?\n\nUX/UI Design and the Final Project Module will focus on these skills","the-curriculum-a-spider-web#The Curriculum: a Spider Web":"It's helpful to imagine the DeNepo curriculum as a spider web with two types of\nthread:\nSkills: The lines going out from the center represent the skills you will\npractice each and every week.\nTechnologies: The circles going out from the center represent the\nlanguages and technologies you will learn in each module.\n\nThe Workflows modules starts in the center of this spider's web. You will\nalready be practicing all of the skills but with projects that use only\nMarkdown. Because Markdown is small and simple you will be free to focus on more\nimportant things like communication and code review.After you have practiced working on full group projects written in markdown, you\nwill expand to the second circle with the Agile Development module. This is\nwhen you learn how to collaboratively plan and develop web pages written with\nHTML and CSS. You will continue practicing all of the skills you learned in\nWorkflows, only now the programming languages will be more complex.... and so on, forever! DeNepo is just the beginning. Your web will continue to\ngrow after you finish studying this curriculum, you practice the skills in your\nweb and add rings of new languages and technologies.","using-the-curriculum#Using the Curriculum":"One way to use the De Nepo web development curriculum is to set up your own Class Repository using the Class Repo Template.This is how we ran our courses for several years. It's a light-weight solution for sharing the learning path, managing assignments, class calendar, questions, and code review.\nTo learn how we ran our courses, read the class repo guides.\nTo learn how you can set up your own class repo, read the /admin documentation."}},"/study-lenses":{"title":"Study Lenses","data":{"":"Study code, not explanations.\nStudy Lenses is a design principle for learning environments that prioritizes code comprehension and investigation. The reasoning behind Study Lenses goes something like this:\nExplicitly teach learners how to study and understand code.\nProvide tools that support free code investigation.\nWrite level-appropriate programs for your learners to study.\nLearners explore the code freely, with your study suggestions.\n\nWatch this little guide before reading on, the rest of this page will make more sense once you've seen Study Lenses in action:\n\n\n\n\n\nDownload the Guide","peel-away-design#Peel-Away Design":"Think if Study Lenses as training wheels one a bike, not as a tricycle. Study Lenses adds layers of support on top of existing development environments. As learners progress they should be able to peel away these layers to reveal a full-fledged programming environment.Lenses add news way of seeing, understand and explore a program. Lenses do not change the way your programming environment or runtime works. As an educator you can configure Study Lenses to suggest to suggest which lenses may be most helpful for a specific program, but learners are always free to ignore your suggestions and either use a lens of their choosing or ignore Study Lenses all together and simply run their code in its native runtime.","accesible-authoring#Accesible Authoring":"Three of the most important design constraints behind Study Lenses work together to ensure learners and educators can easily adapt and own their curriuclum:\nAll code should be content: A learner should be able to open any file of JavaScript code and use Study Lenses to understand it.\nRely only on web-standard syntax & languages: Programs written and configured to be used with Study Lenses should not rely on any non-standard syntax, every should be valid code or data that can be reused elsewhere.\nContent curation should use standard develpoment workflows: All Study Lenses content should be hosted, developed, versioned, and distributed as a standard code base. A learner or educator with experience using Git, GitHub and an IDE should already have all the technical skills necessary to curate their own curriculum.","implementations#Implementations":"Study Lenses is an idea not an implementation, and because each programming language and each development environment is different, there can never be one Study Lenses. You would need to design and build one implementation for each setting. Study Lenses could be implemented as an IDE plugin, as features in an existing learning environment, or as a stand-alone application.","for-the-browser#For the Browser":"source: DeNepo/study-lenses\ninstall: npm i -g study-lenses\nThis implementation is designed for learning JavaScript/HTML/CSS offline, so it is built around a localhost web server and opens code to study in a new browser tab. Learners can explore their code in different lenses by changing the page's URL queries (see the demo video at the top of this page). The \"home base\" lens (called study) is simply a code editor; because this implementation was designed for teaching web development, the learner is expected to practice using their browser's devtools to run, trace and debug their JavaScript. This implementation is designed around a plugin system, so developers are not limited to the lenses that ship with Study Lenses.You can try the online Study Lenses demo (this may take a minute to start up if no one has used it in a while). Besides showcasing the Study Lenses learning environment, it also shows different ways you can organize programs for learners to explore.Or you can clone the demo repository and try the demo locally to save your changes.You can also install Study Lenses as a global NPM module and use it to open any folder of JavaScript/HTML/CSS, adding layers of study to any existing code:\n$ npm install -g study-lenses\n$ cd <a-folder-of-js-html-css>\n$ study","for-vscode#For VSCode":"source: yoshimalaise/Explorotron\ninstall: VSCode Marketplace\nThe extension allows learners to add new perspectives and layers of interactivity on top of existing JavaScript Code. Every lens focuses on a specific aspect of the code that has to be studied. Lenses follow CER best practices such as PRIMM, scaffolding and expertise reversal. For more information on the theory behind the extension we suggest reading our papers on Computing Education [CSEDU, Koli Calling]."}}}